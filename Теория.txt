
СУБД-Система Управления Базой Данных
Реляц.VS Нереляц.- 1.Используют SQL
		   2.Не используют SQL	
Реляционные-основывается на реляц алгебре
Char-Точное количество символов,полностью заполняется
Varchar-Допускает не полное заполнение
Distinct-Убирает повторы
Between- >= <= знаки НЕ строгие,включающие
Order by- сортировка по порядку ASC(убыль),DESC(возраст)
References - ссылка используется для создания внешнего ключа определяя на какую таблицу будет /n
будет ссылаться наша таблица /n
*CustomerId*(сущность нашей таблицы) INTEGER REFERENCES 'Customers(другая таблица) (Id)(ее сущность)',
Having - постфильтр, используется после group by 
UNION(объединение) - используется для объединения 2 запросов из 2 разных таблиц select .. from .. UNION select .. from .. => 1 таблица /n
Удаляет все дупликаты
INTERSECT(пересечение)- такой же синтаксис как и в UNION,используется для поиска пересечений 2 запросов из 2 разных таблиц
EXCEPT(исключение)- такой же синтаксис как и в UNION, используется уникальных значений в 1 таблице,которых нет во 2-ой 
INNER JOIN=JOIN
USING - сокращение ON пример: JOIN product ON order.product_id = product.product_id /n
Тоже самое что и JOIN product USING(product_id)
CONCAT(first,' ',second)-объединение в 1 наименование
Вложенный запрос=> Синтаксис select.. from ... where (select from) работает с limit и тд
where exists возвращает значения true или false 
Структура 
select customer_price
from customers
where exists(select customer_id
	     from orders
	     where customer_id=customers.customer_id)
Другими словами с помощью "customer_id=customers.customer_id" реализуется join а за логику отвечает exists
all и any и Exists - работает только с подзапросами.
all подразумевает работу со всеми значениями.
any с любыми подходящими условяю.
==============================================================Нужна практика!

DDL 
TRUNCATE -удаляет ДАННЫЕ из таблицы
Для коректной работы используется такой синтаксик /n
truncate table NAME (restart identity) пишется для того чтобы обновить порядок записи номера column 
serial - тип данных который оставляет только положит значения,автозаполняемый
Переименовать таблицу 
alter table NAME
rename to NEW_NAME
Переименовать колону 
alter table NAME_TABLE
rename OLD_COLUMN_NAME to NEW_COLUMN_NAME
PRIMARY KEY=UNIQUE NOT NULL
Но UNIQUE может использоваться больше 1 раза,и не отмечается как первичный ключ
Задать PRIMARY KEY можно как во время создания таблицы /n
create table name(
	name_id int PRIMARY KEY,
	ЛИБO
	CONTAINT PK_NAME_NAME_ID(так мы обзываем имя ограничения/n
				 pk=primary key name=table_name name_id=name_id с primary key) PRIMARY KEY(NAME_ID)
)

ALTER TABLE name_1 
ADD CONTRAINT FK_name_1_name_2 foreign key(name_2_id) references name_2(name_2_id)
DROP CONTRAINT

CHECK - используется для добавления логического условия к заполнению в новой таблице
ALTER TABLE book 
ADD COLUMN price decimal CONSTRAINT CHK_book_price CHECK(price>0)

DEFAULT - используется для заполнения столбца таблицы заданным значением в том случае если его не заполнить
ALTER TABLE name
ALTER COLUMN name SET DEFAULT '..'

SEQUENCE-последовательность
SELECT NEXTVAL('name_seq')-следующее значение последовательности
SELECT CURRVAL('name_seq') -текущее значение последовательности
SELECT LASTVAL()-последнее значение последовательности ВАЖНО(работает без выбора конткретной последовательности)
SELECT SETVAL('name_seq',16,true/false)-добавления значения в последовательность
Полный синтаксис SEQUENCE
CREATE NAME
INCREMENT 16 - ШАГ
MINVALUE 0 - минимальное значение
MAXMALUE 128 - максимальное значение
START WITH 0; - первое значение nextval

Для реализации автоинкремента в таблице
----Создание последовательности и внедрение значений в столбец----
CREATE SEUQENCE IF NOT EXISTS book_book_id_seq
START WITH 1 OWNED BY book.book_id - OWNED- означает внедрение значения в определенный столбец
----Задаем DEFAULT для таблицы----
ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('seq')

Правильный синтаксис заполнения id с автоинкрементом и защитой от заполнения в ручную
Главная проблема SERIAL- в том,что если кто то в ручную задаст данные,то система начнет /n
выдавать ошибку так как значение будет уже занято
------------Решение----------
book_id INT GENERATED ALWAYS AS IDENTITY NOT NULL
Это строчка не будет давать возможность через классически INSERT INTO задавать значения 
Но можно и обойти это ограничение
INSERT INTO book
OVERRIDING SYSTEM VALUE--обход ограничения
VALUES(...)
Т.к. GENERATED ALWAYS AS IDENTITY основанна на SEUQENCE то преемлен такой м
GENERATED ALWAYS AS IDENTITY(START WITH 10 INCREMENT BY 2)
Для RESTART нашей таблицы с последовательность можно просто обратиться к самой таблице 
ALTER TABLE name 
ALTER COLUMN name RESTART WITH 0 
Без использования имени SEQ

---------------Быстрое создание таблицы коппируя таблицы С УСЛОВИЕМ
SELECT *
INTO best_authors
FROM author
WHERE rating >4
------------Быстрое коппирование данных из 1 таблицы во 2 
INSERT INTO best_authors
SELECT *
FROM author
WHERE ...-также можем использовать любое условие
-----------Изменение КОНКРЕТНОЙ строки 
UPDATE table_name
SET full_name='123'
WHERE full_id = '1'-используется для опознания КОНКРЕТНОЙ таблицы
-----------Удаление КОНКРЕТНОЙ строки 
DELETE FROM author
WHERE ...
=================================ОШИБКИ
START WITH 1 OWNED BY book.book_id - OWNED- означает внедрение значения в определенный столбец
----Задаем DEFAULT для таблицы----
ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('seq')
ADD CONSTRAINT CHK_products_unit_price CHECK(unit_price>0)-добавление ограничений
---------------------------VIEW
View-сохраненный запрос в виде объекта Бд-для пользователей 
Важно при создании!! Не дает работать с limit,distinct,group by,having,union,MAX,MIN 
Работает с ORDER BY,WHERE
Очень жесткие ограничения по изменению поэтому используется пересоздание 
CREATE OR REPLACE VIEW-используется для изменения УСЛОВИЯ 
Добавлять новые таблицы изменять порядок НЕЛЬЗЯ поэтому сначала нужно удалить а потом создать новую VIEW
Можно добавлять кортежи противоречивающие условию VIEW 
Чтобы исправить WITH LOCAL CHECK OPTION
--------------------------CASE WHEN 

CASE 
    WHEN condition_1 THEN result_1
    WHEN condition_2 THEN result_2
    ELSE result_n 
END
-condition-условие 
-result_1-результат или действие если condition_1 вернула TRUE
В случае если первый WHEN вернула FALSE то переходит к след WHEN и так до END
Синтаксис:
SELECT product_name,unit_price,units_in_stock,
	CASE WHEN units_in_stock >= 100 THEN 'lot of'
		 WHEN units_in_stock > 50 and units_in_stock< 100 THEN 'average'
		 WHEN units_in_stock < 50 THEN 'low'
		 ELSE 'unknown'
	END AS amount
FROM products 
ORDER BY units_in_stock DESC
Используется как отдельный СТОЛБЕЦ
=================================COALESCE&NULLIF
COALESCE-возвращает первое значение которое NOT NULL если все NULL то NULL(простыми словами замена NULL на что то)
NULLIF-сравнивает 2 аргумента и если они равны то возвращает NULL,а если нет то 1arg(изменяет значение,которое нам не нравится на NULL)
Пример:
COALESCE(NULLIF(city,''),'unknown')-используем замену пустых строк в city,на unknown
Пример сравнения:
ТЗ-узнать значение где current=previos
COALESCE(TO_CHAR(NULLIF(current,previos),'FM999'),'unknown')
 (coalesce работает только с символами) (кодировка для CHAR)
ВАЖНО!!!!!!!
otder_id::TEXT-быстрая конвертация
==================================ФУНКЦИИ SQL
Делять на
1.SQL-функции
2.Процедурные
3.Серверные
4.Собственные С-функции
Синтаксис:
CREATE FUNCTION func_name([arg1,arg2..]) RETURNS data_type AS $$
$$ LANGUAGE lang

create or replace function fix_null() returns void as 
$$
update tmp_customers
	set region='unknown'
	where region is null
$$ language SQL;

Функция называется скалярной если она возвращает какое то единственное значение.
Пример 
create or replace function sum_products() 
returns bigint as $$
	select sum(units_in_stock)
	from products
$$ language sql;
===Функции с аргументами(....)
IN-входящие аргументы
OUT-исходящие аргументы
INOUT-входящий и исходящий
VARIADIC-массив входящих параметров
Синтаксис 
create or replace function get_product_price(prod_name varchar) returns real as $$
	select unit_price 
	from products
	where product_name=prod_name
$$ language sql;

select get_product_price('Chocolade') as price;
Вывод цены определеного продукта по названию в нашем случае 'Chocolade'

===Функция с 2 OUT
ТЗ:вывести максимальную и минимальную цену продуктов

create or replace function get_max_min(OUT max_price real,OUT min_price real) as $$
	select max(unit_price),min(unit_price)
	from products
$$
language sql;

Так как у нас есть OUT=> real то returns не пишется !!!!!!!!
Для корректного вывода 2 и более аргументов OUT используется такой синтаксис:
select *
function_name();

===Использование DEFAULT
create or replace function_name(IN 1_arg int *DEFAUL* 1)

===Возврат множества строк
-RETURNS SETOF data_type возврат n-значений типа data_type
-RETURNS SETOF table если нужно вернуть все столбы из таблицы или пользоват типа
-RETURNS SETOF record используются когда типы колонок заранее не известны
-RETURNS TABLE(column_name date_tyoe,..) тоже что и setof table,но имеем возможность явно указать возвращ стобцы

Returns setof используется для вывода n1,n2,n3... кортежей в таблице с 2 и более столбцами 
Без returns вывод:
AVG_price||SUM_price
---------------------
123	 || 218

Вывод с returns:
AVG_price||SUM_price
---------------------
123	 || 218
4345	 || 24234
63	 || 4678
53	 || 1246
------Редкий случай:
В случае использования RETURNS SETOF record без указания data_type (OUT 1_arg data_type),его придется указывать при вызове функции /n
Пример select * from function_name() AS (1_arg data_type,2_arg data_type)